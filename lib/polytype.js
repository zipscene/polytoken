const XError = require('xerror');

/**
 * This class is generated by the makePolytype() method on Polytoken. It receives a specification of
 * the dimensions that make up this Polytype, including their respective tokenConfigs. It provides the methods used
 * to generate token for both a range and point.
 *
 * @class Polytype
 * @constructor
 * @param {Array[Dimension]} dimensions - The dimensions that comprise this Polytype.
 */
class Polytype {

	constructor(dimensions, delimiter = '&') {
		this.dimensions = dimensions;
		this.delimiter = delimiter;
	}

	/**
	 * Generate and return a set of tokens that contain the given range tuple as accurately as possible.
	 *
	 * @method getRangeTokens
	 * @param {Array[Mixed]} rangeTuple
	 * @return {Array[String]} tokens - Set of tokens which comprise this range.
	 */
	getRangeTokens(rangeTuple) {
		// TODO
		// rangeTuple should contain a range object for every dimension, in order. For each, validate the range
		// object, then generate the range tokens. Then, each set of tokens will need to multiplied together to
		// form the full set. We can talk about the actual structure of the tokens.
		return this.getPolyTypeTokens('range', rangeTuple);
	}

	/**
	 * Return the set of tokens to which a point can potentially belong. Any tokenized range that contains at least
	 * one of these tokens also contains this point.
	 *
	 * @method getTokensForPoint
	 * @param {Array[Mixed]} pointTuple
	 * @return {Array[String]} token - Set of tokens which contain this point.
	 */
	getTokensForPoint(pointTuple) {
		// TODO
		// Similar to getRangeTokens; get the set of tokens for each point then multiply them.
		return this.getPolyTypeTokens('point', pointTuple);
	}

	getPolyTypeTokens(type, tuple) {
		if (!tuple) return [];
		if (!Array.isArray(tuple)) { throw new XError(`${type} tuple must be an array`); }
		if (tuple.length !== this.dimensions.length) {
			throw new XError(`${type} tuple length must equal to number of dimensions`);
		}

		let dimensionTokens = [];
		for (let i = 0; i < tuple.length; i++) {
			let element = tuple[i];
			let dimension = this.dimensions[i];
			let curDimensionTokens = [];
			if (type === 'point') {
				curDimensionTokens = dimension.getTokensForPoint(element);
			} else {
				curDimensionTokens = dimension.getRangeTokens(element);
			}
			dimensionTokens.push(curDimensionTokens);
		}
		let tokens = [];
		this._getTokens(dimensionTokens, 0, '', tokens);
		return tokens;
	}

	_getTokens(dimensionTokens, index, token = '', tokens = []) {
		if (index === this.dimensions.length) {
			tokens.push(token);
			return;
		}
		let dimension = this.dimensions[index];
		for (let dimensionToken of dimensionTokens[index]) {
			if (token.indexOf(this.delimiter) >= 0) {
				throw new XError(`${dimension.getName()} token contains polytype token delimiter ${this.delimiter}`);
			}
			let curToken = `${token}${dimensionToken}`;
			if (index < this.dimensions.length - 1) curToken += this.delimiter;
			this._getTokens(dimensionTokens, index + 1, curToken, tokens);
		}
	}

}

module.exports = Polytype;
