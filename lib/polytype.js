// Copyright 2016 Zipscene, LLC
// Licensed under the Apache License, Version 2.0
// http://www.apache.org/licenses/LICENSE-2.0

const XError = require('xerror');
const Dimension = require('./dimension');

/**
 * This class is generated by the makePolytype() method on Polytoken. It receives a specification of
 * the dimensions that make up this Polytype, including their respective tokenConfigs. It provides the methods used
 * to generate token for both a range and point.
 *
 * @class Polytype
 * @constructor
 * @param {Dimension[]} dimensions - The dimensions that comprise this Polytype.
 * @param {string} delimiter - the delimiter to use to concatenate dimension tokens
 */
class Polytype {

	constructor(dimensions, delimiter = '&') {
		this.delimiter = delimiter;

		if (!Array.isArray(dimensions)) {
			throw new XError(XError.INVALID_ARGUMENT, 'dimensions must be an array');
		}
		for (let dimension of dimensions) {
			if (!(dimension instanceof Dimension)) {
				throw new XError(XError.INVALID_ARGUMENT, `${dimension} is not an instance of Dimension`);
			}
		}

		this.dimensions = dimensions;
	}

	/**
	 * Generate and return a set of tokens that contain the given range tuple as accurately as possible.
	 *
	 * @method getRangeTokens
	 * @param {Mixed[]} rangeTuple
	 * @return {String[]} tokens - Set of tokens which comprise this range.
	 */
	getRangeTokens(rangeTuple) {
		return this._getPolyTypeTokens('range', rangeTuple);
	}

	/**
	 * Return the set of tokens to which a point can potentially belong. Any tokenized range that contains at least
	 * one of these tokens also contains this point.
	 *
	 * @method getTokensForPoint
	 * @param {Mixed[]} pointTuple
	 * @return {String[]} token - Set of tokens which contain this point.
	 */
	getTokensForPoint(pointTuple) {
		return this._getPolyTypeTokens('point', pointTuple);
	}

	/**
	 * Generate polyType tokens given either an array of ranges or an array of points
	 *
	 * @method _getPolyTypeTokens
	 * @private
	 * @param {String} type - can either be 'ramge' or 'poimt'
	 * @param {Mixed[]} tuple - an array of ranges or points, Should be consistant with `type`
	 * @throws {XError} - throws an xerror instance with code `invalid_argument`
	 * @return {String[]} - return generated tokens
	 */
	_getPolyTypeTokens(type, tuple) {
		if (!tuple) return [];
		if (!Array.isArray(tuple)) { throw new XError(XError.INVALID_ARGUMENT, `${type} tuple must be an array`); }
		if (tuple.length !== this.dimensions.length) {
			throw new XError(XError.INVALID_ARGUMENT, `${type} tuple length must equal to number of dimensions`);
		}

		let dimensionTokens = [];
		for (let i = 0; i < tuple.length; i++) {
			let element = tuple[i];
			let dimension = this.dimensions[i];
			let curDimensionTokens = [];
			if (type === 'point') {
				curDimensionTokens = dimension.getTokensForPoint(element);
			} else {
				curDimensionTokens = dimension.getRangeTokens(element);
			}
			dimensionTokens.push(curDimensionTokens);
		}
		let tokens = [];
		this._getTokens(dimensionTokens, 0, '', tokens);
		return tokens;
	}

	/**
	 * Recursively "multiply" the given dimension tokens and generate tokens for this polytype.
	 *
	 * @method _getTokens
	 * @private
	 * @param {String[][]} dimensionTokens - array of tokens generated by each dimension
	 * @param {Number} index - index of current dimension in the array
	 * @param {String} token - the polytype token generated b so far iterated dimensions
	 * @param {string[]} tokens - generated tokens so far
	 */
	_getTokens(dimensionTokens, index, token = '', tokens) {
		if (index === this.dimensions.length) {
			tokens.push(token);
			return;
		}
		let dimension = this.dimensions[index];
		for (let dimensionToken of dimensionTokens[index]) {
			if (dimensionToken.indexOf(this.delimiter) >= 0) {
				throw new XError(`${dimension.getName()} token contains polytype token delimiter ${this.delimiter}`);
			}
			let curToken = `${token}${dimensionToken}`;
			if (index < this.dimensions.length - 1) curToken += this.delimiter;
			this._getTokens(dimensionTokens, index + 1, curToken, tokens);
		}
	}

	/**
	 * Perform a definitive test on whether the given range includes the given point. This is used
	 * because the tokenization done by this libray is an approximation. If an accurate result is desired, this
	 * can be called after a database query on the tokens returns, in order to filter out the 'accidental' matches.
	 *
	 * @method checkRangeInclusion
	 * @param {Mixed} rangeTuple
	 * @param {Mixed} pointTuple
	 * @return {Boolean} - True if the point is inside the range, false otherwise.
	 */
	checkRangeInclusion(rangeTuple, pointTuple) {
		if (rangeTuple.length !== this.dimensions.length || pointTuple.length !== this.dimensions.length) {
			throw new XError(XError.INVALID_ARGUMENT, 'Tuple length must be equal to number of dimensions');
		}
		for (let i = 0; i < this.dimensions.length; i++) {
			let dimension = this.dimensions[i];
			if (!dimension.checkRangeInclusion(rangeTuple[i], pointTuple[i])) return false;
		}
		return true;
	}

}

module.exports = Polytype;
